{"version":3,"file":"identify-and-store-ingestable-types.js","names":["identifyAndStoreIngestableFieldsAndTypes","nodeListFilter","field","name","state","store","getState","introspectionData","fieldBlacklist","typeMap","remoteSchema","pluginOptions","gatsbyApi","cachedFetchedTypes","getPersistentCache","key","restoredFetchedTypesMap","Map","dispatch","setState","fetchedTypes","nodeInterfaceTypes","nodeListRootFields","nonNodeRootFields","nodeInterfacePossibleTypeNames","type","Object","entries","forEach","typeName","typeSettings","lazyNodes","__all","typeIsExcluded","lazyType","get","addFetchedType","nodeInterface","push","rootFields","fields","fieldHasNonNullArgs","args","some","arg","kind","nodeField","find","findNamedType","nodeListField","findNamedTypeName","nodeListFieldType","innerField","nodeInterfaceType","possibleTypes","includes","takesIDinput","RootQuery","excludeFieldNames","excludedFieldName","typeIsABuiltInScalar","interfaces","__schema","types","filter","interfaceType","typesThatImplementInterface","getTypesThatImplementInterfaceType","shouldSkipInterfaceType","transformFields","parentType","parentInterfacesImplementingTypes","peek","interfaceField","nodeListFieldNames","map","nodeListTypeNames","connectionType","nodesField","gatsbyNodesInfo","fieldNames","typeNames","ingestibles"],"sources":["../../../src/steps/ingest-remote-schema/identify-and-store-ingestable-types.js"],"sourcesContent":["import store from \"~/store\"\nimport { typeIsExcluded } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { typeIsABuiltInScalar } from \"../create-schema-customization/helpers\"\nimport {\n  findNamedTypeName,\n  getTypesThatImplementInterfaceType,\n  findNamedType,\n} from \"~/steps/create-schema-customization/helpers\"\nimport { transformFields } from \"../create-schema-customization/transform-fields\"\nimport { getPersistentCache } from \"~/utils/cache\"\n\nconst identifyAndStoreIngestableFieldsAndTypes = async () => {\n  const nodeListFilter = field => field.name === `nodes`\n\n  const state = store.getState()\n  const { introspectionData, fieldBlacklist, typeMap } = state.remoteSchema\n  const { pluginOptions } = state.gatsbyApi\n\n  const cachedFetchedTypes = await getPersistentCache({\n    key: `previously-fetched-types`,\n  })\n\n  if (cachedFetchedTypes) {\n    const restoredFetchedTypesMap = new Map(cachedFetchedTypes)\n\n    store.dispatch.remoteSchema.setState({\n      fetchedTypes: restoredFetchedTypesMap,\n    })\n  }\n\n  const nodeInterfaceTypes = []\n  const nodeListRootFields = []\n  const nonNodeRootFields = []\n  const nodeInterfacePossibleTypeNames = []\n\n  if (pluginOptions.type) {\n    Object.entries(pluginOptions.type).forEach(([typeName, typeSettings]) => {\n      // our lazy types won't initially be fetched,\n      // so we need to mark them as fetched here\n      if (\n        (typeSettings.lazyNodes || pluginOptions.type?.__all?.lazyNodes) &&\n        !typeIsExcluded({ pluginOptions, typeName })\n      ) {\n        const lazyType = typeMap.get(typeName)\n        store.dispatch.remoteSchema.addFetchedType(lazyType)\n      }\n\n      if (typeSettings.nodeInterface) {\n        nodeInterfaceTypes.push(typeName)\n      }\n    })\n  }\n\n  const rootFields = typeMap.get(`RootQuery`).fields\n\n  for (const field of rootFields) {\n    const fieldHasNonNullArgs = field.args.some(\n      arg => arg.type.kind === `NON_NULL`\n    )\n\n    if (fieldHasNonNullArgs) {\n      // we can't know what those args should be, so skip this field\n      continue\n    }\n\n    if (typeIsExcluded({ pluginOptions, typeName: field.type.name })) {\n      continue\n    }\n\n    if (field.type.kind === `OBJECT`) {\n      const type = typeMap.get(field.type.name)\n\n      const nodeField = type?.fields?.find(nodeListFilter)\n\n      if (nodeField && findNamedType(nodeField.type).kind === `INTERFACE`) {\n        const nodeListField = type.fields.find(nodeListFilter)\n\n        if (nodeListField) {\n          nodeInterfaceTypes.push(findNamedTypeName(nodeListField.type))\n\n          store.dispatch.remoteSchema.addFetchedType(nodeListField.type)\n\n          const nodeListFieldType = typeMap.get(\n            findNamedTypeName(nodeListField.type)\n          )\n\n          for (const innerField of nodeListFieldType.fields) {\n            store.dispatch.remoteSchema.addFetchedType(innerField.type)\n          }\n\n          if (\n            // if we haven't marked this as a nodeInterface type then push this to root fields to fetch it\n            // nodeInterface is different than a node which is an interface type.\n            // In Gatsby nodeInterface means the node data is pulled from a different type. On the WP side we can also have nodes that are of an interface type, but we only pull them from a single root field\n            // the problem is that if we don't mark them as a node list root field\n            // we don't know to identify them later as being a node type that will have been fetched and we also wont try to fetch this type during node sourcing.\n            !pluginOptions?.type?.[findNamedTypeName(nodeListField.type)]\n              ?.nodeInterface\n          ) {\n            const nodeInterfaceType = typeMap.get(\n              findNamedTypeName(nodeListField.type)\n            )\n\n            // we need to mark all the possible types as being fetched\n            // and also need to record the possible type as a node type\n            for (const type of nodeInterfaceType?.possibleTypes || []) {\n              nodeInterfacePossibleTypeNames.push(type.name)\n              store.dispatch.remoteSchema.addFetchedType(type)\n            }\n\n            nodeListRootFields.push(field)\n          }\n\n          continue\n        }\n      } else if (nodeField) {\n        if (fieldBlacklist.includes(field.name)) {\n          continue\n        }\n\n        store.dispatch.remoteSchema.addFetchedType(nodeField.type)\n\n        nodeListRootFields.push(field)\n        continue\n      }\n    }\n\n    if (fieldBlacklist.includes(field.name)) {\n      continue\n    }\n\n    const takesIDinput = field?.args?.find(arg => arg.type.name === `ID`)\n\n    // if a non-node root field takes an id input, we 99% likely can't use it.\n    // so don't fetch it and don't add it to the schema.\n    if (takesIDinput) {\n      continue\n    }\n\n    if (\n      // if this type is excluded on the RootQuery, skip it\n      pluginOptions.type.RootQuery?.excludeFieldNames?.find(\n        excludedFieldName => excludedFieldName === field.name\n      )\n    ) {\n      continue\n    }\n\n    // we don't need to mark types as fetched if they're supported SCALAR types\n    if (!typeIsABuiltInScalar(field.type)) {\n      store.dispatch.remoteSchema.addFetchedType(field.type)\n    }\n\n    nonNodeRootFields.push(field)\n  }\n\n  const interfaces = introspectionData.__schema.types.filter(\n    type => type.kind === `INTERFACE`\n  )\n\n  for (const interfaceType of interfaces) {\n    if (typeIsExcluded({ pluginOptions, typeName: interfaceType.name })) {\n      continue\n    }\n\n    if (!interfaceType.fields) {\n      continue\n    }\n\n    const typesThatImplementInterface =\n      getTypesThatImplementInterfaceType(interfaceType)\n\n    const shouldSkipInterfaceType = !transformFields({\n      fields: interfaceType.fields,\n      parentType: interfaceType,\n      parentInterfacesImplementingTypes: typesThatImplementInterface,\n      peek: true,\n    })\n\n    if (shouldSkipInterfaceType && interfaceType.name !== `Node`) {\n      continue\n    }\n\n    store.dispatch.remoteSchema.addFetchedType(interfaceType)\n\n    if (interfaceType.fields) {\n      for (const interfaceField of interfaceType.fields) {\n        if (interfaceField.type) {\n          store.dispatch.remoteSchema.addFetchedType(interfaceField.type)\n        }\n      }\n    }\n  }\n\n  const nodeListFieldNames = nodeListRootFields.map(field => field.name)\n\n  const nodeListTypeNames = [\n    ...nodeInterfacePossibleTypeNames,\n    ...nodeListRootFields.map(field => {\n      const connectionType = typeMap.get(field.type.name)\n\n      const nodesField = connectionType.fields.find(nodeListFilter)\n      return findNamedType(nodesField.type).name\n    }),\n  ]\n\n  const gatsbyNodesInfo = {\n    fieldNames: nodeListFieldNames,\n    typeNames: nodeListTypeNames,\n  }\n\n  store.dispatch.remoteSchema.setState({\n    gatsbyNodesInfo,\n    ingestibles: {\n      nodeListRootFields,\n      nonNodeRootFields,\n      nodeInterfaceTypes,\n    },\n  })\n}\n\nexport { identifyAndStoreIngestableFieldsAndTypes }\n"],"mappings":"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"}