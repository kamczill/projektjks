{"version":3,"file":"build-query-on-field-name.js","names":["buildReusableFragments","fragments","Object","values","map","name","type","fields","inlineFragments","buildSelectionSet","buildInlineFragments","join","generateReusableFragments","selectionSet","fragmentsValues","length","builtFragments","regenerateFragments","forEach","includes","buildNodesQueryOnFieldName","fieldName","builtSelectionSet","queryVariables","fieldVariables","buildQuery","queryName","variables","buildVariables","buildInlineFragment","inlineFragment","transformedInlineFragments","remoteSchema","typeMap","store","getState","buildFieldSelectionSet","field","fieldType","internalType","fragment","find","builtInlineFragments","fullFieldType","get","findNamedTypeName","inlineFragmentsSelectionSet","filter","Boolean","buildNodeQueryOnFieldName","fieldInputArguments"],"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/build-query-on-field-name.js"],"sourcesContent":["import store from \"~/store\"\nimport { findNamedTypeName } from \"~/steps/create-schema-customization/helpers\"\n\nconst buildReusableFragments = ({ fragments }) =>\n  Object.values(fragments)\n    .map(\n      ({\n        name,\n        type,\n        fields,\n        inlineFragments,\n      }) => `fragment ${name} on ${type} {\n      ${buildSelectionSet(fields)}\n      ${buildInlineFragments(inlineFragments)}\n    }`\n    )\n    .join(` `)\n\n/**\n * Takes in a fragments object (built up during the buildSelectionSet function)\n * transforms that object into an actual fragment,\n * then checks for unused fragments and potential regenerates again\n * with the unused fragments removed\n */\nexport const generateReusableFragments = ({ fragments, selectionSet }) => {\n  const fragmentsValues = Object.values(fragments)\n\n  if (!fragmentsValues.length) {\n    return ``\n  }\n\n  let builtFragments = buildReusableFragments({ fragments })\n\n  if (fragments) {\n    let regenerateFragments = false\n\n    fragmentsValues.forEach(({ name, type }) => {\n      // if our query didn't use the fragment due to the query depth AND the fragment isn't used in another fragment, delete it\n      // @todo these fragments shouldn't be generated if they wont be used.\n      // if we fix this todo, we can use the buildReusableFragments function directly\n      // instead of running it twice to remove unused fragments\n      if (\n        !selectionSet.includes(`...${name}`) &&\n        !builtFragments.includes(`...${name}`)\n      ) {\n        delete fragments[type]\n        regenerateFragments = true\n      }\n    })\n\n    if (regenerateFragments) {\n      builtFragments = buildReusableFragments({ fragments })\n    }\n  }\n\n  return builtFragments\n}\n\nexport const buildNodesQueryOnFieldName = ({\n  fieldName,\n  builtSelectionSet,\n  builtFragments = ``,\n  queryVariables = ``,\n  fieldVariables = ``,\n}) =>\n  buildQuery({\n    queryName: `NODE_LIST_QUERY`,\n    variables: `$first: Int!, $after: String, ${queryVariables}`,\n    fieldName,\n    fieldVariables: `first: $first, after: $after, ${fieldVariables}`,\n    builtSelectionSet: `\n        nodes {\n          ${builtSelectionSet}\n        }\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n      `,\n    builtFragments,\n  })\n\nconst buildVariables = variables =>\n  variables && typeof variables === `string` ? `(${variables})` : ``\n\nconst buildInlineFragment = ({ name, fields, fragments }) => `\n  ... on ${name} {\n    ${buildSelectionSet(fields, { fragments })}\n  }\n`\n\nconst buildInlineFragments = (inlineFragments, { fragments = {} } = {}) =>\n  inlineFragments\n    ? `\n      __typename\n      ${inlineFragments\n        .map(inlineFragment =>\n          buildInlineFragment({ ...inlineFragment, fragments })\n        )\n        .join(` `)}\n    `\n    : ``\n\nexport const buildSelectionSet = (\n  fields,\n  { fragments = {}, transformedInlineFragments = [] } = {}\n) => {\n  if (!fields || !fields.length) {\n    return ``\n  }\n\n  const {\n    remoteSchema: { typeMap },\n  } = store.getState()\n\n  const buildFieldSelectionSet = field => {\n    if (typeof field === `string`) {\n      return field\n    }\n\n    let {\n      fieldName,\n      variables,\n      fields,\n      inlineFragments,\n      fieldType,\n      internalType,\n      builtSelectionSet,\n    } = field\n\n    if (internalType === `Fragment`) {\n      return `...${field.fragment.name}`\n    }\n\n    if (\n      (!variables || variables === ``) &&\n      fields?.find(field => field.fieldName === `nodes`)\n    ) {\n      // @todo instead of checking for a nodes field, include the field type here\n      // and check for input args instead. Maybe some kind of input args API or something would be helpful\n      variables = `first: 100`\n    }\n\n    const selectionSet =\n      builtSelectionSet ||\n      buildSelectionSet(fields, {\n        fragments,\n      })\n\n    const builtInlineFragments = buildInlineFragments(inlineFragments, {\n      fragments,\n    })\n\n    if (fieldName && (builtInlineFragments !== `` || selectionSet !== ``)) {\n      return `\n        ${fieldName} ${buildVariables(variables)} {\n          ${selectionSet}\n          ${builtInlineFragments}\n        }\n      `\n    } else if (fieldName) {\n      const fullFieldType = typeMap.get(findNamedTypeName(fieldType))\n\n      // if this field has subfields but we didn't build a selection set for it\n      // we shouldn't fetch this field. This can happen when we have self referencing types that are limited by the schema.circularQueryLimit plugin option.\n      // @todo the above should be fixed in recursively-transform-fields.js instead of here. recursion is hard :p\n      if (fullFieldType.fields) {\n        return null\n      }\n\n      return fieldName\n    }\n\n    return null\n  }\n\n  let inlineFragmentsSelectionSet = ``\n\n  if (transformedInlineFragments?.length) {\n    inlineFragmentsSelectionSet = transformedInlineFragments.map(\n      inlineFragment => `... on ${inlineFragment.name} {\n        ${inlineFragment.fields.map(buildFieldSelectionSet).filter(Boolean)\n          .join(`\n        `)}\n      }`\n    )\n  }\n\n  const selectionSet = fields.map(buildFieldSelectionSet).filter(Boolean).join(`\n    `)\n\n  return `${inlineFragmentsSelectionSet} ${selectionSet}`\n}\n\nconst buildQuery = ({\n  queryName,\n  fieldName,\n  fieldVariables,\n  variables,\n  builtSelectionSet,\n  builtFragments = ``,\n}) => `\n  query ${queryName} ${buildVariables(variables)} {\n    ${fieldName} ${buildVariables(fieldVariables)} {\n      ${builtSelectionSet}\n    }\n  }\n\n  ${builtFragments}\n`\n\nexport const buildNodeQueryOnFieldName = ({\n  fieldName,\n  builtFragments,\n  builtSelectionSet,\n  variables = `$id: ID!`,\n  fieldInputArguments = `id: $id`,\n  queryName = `SINGLE_CONTENT_QUERY`,\n}) =>\n  buildQuery({\n    queryName,\n    variables,\n    fieldName,\n    fieldVariables: fieldInputArguments,\n    builtFragments,\n    builtSelectionSet,\n  })\n"],"mappings":";;;;;;;AAAA;;AACA;;AAEA,MAAMA,sBAAsB,GAAG,CAAC;EAAEC;AAAF,CAAD,KAC7BC,MAAM,CAACC,MAAP,CAAcF,SAAd,EACGG,GADH,CAEI,CAAC;EACCC,IADD;EAECC,IAFD;EAGCC,MAHD;EAICC;AAJD,CAAD,KAKO,YAAWH,IAAK,OAAMC,IAAK;AACxC,QAAQG,iBAAiB,CAACF,MAAD,CAAS;AAClC,QAAQG,oBAAoB,CAACF,eAAD,CAAkB;AAC9C,MAVE,EAYGG,IAZH,CAYS,GAZT,CADF;AAeA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,yBAAyB,GAAG,CAAC;EAAEX,SAAF;EAAaY;AAAb,CAAD,KAAiC;EACxE,MAAMC,eAAe,GAAGZ,MAAM,CAACC,MAAP,CAAcF,SAAd,CAAxB;;EAEA,IAAI,CAACa,eAAe,CAACC,MAArB,EAA6B;IAC3B,OAAQ,EAAR;EACD;;EAED,IAAIC,cAAc,GAAGhB,sBAAsB,CAAC;IAAEC;EAAF,CAAD,CAA3C;;EAEA,IAAIA,SAAJ,EAAe;IACb,IAAIgB,mBAAmB,GAAG,KAA1B;IAEAH,eAAe,CAACI,OAAhB,CAAwB,CAAC;MAAEb,IAAF;MAAQC;IAAR,CAAD,KAAoB;MAC1C;MACA;MACA;MACA;MACA,IACE,CAACO,YAAY,CAACM,QAAb,CAAuB,MAAKd,IAAK,EAAjC,CAAD,IACA,CAACW,cAAc,CAACG,QAAf,CAAyB,MAAKd,IAAK,EAAnC,CAFH,EAGE;QACA,OAAOJ,SAAS,CAACK,IAAD,CAAhB;QACAW,mBAAmB,GAAG,IAAtB;MACD;IACF,CAZD;;IAcA,IAAIA,mBAAJ,EAAyB;MACvBD,cAAc,GAAGhB,sBAAsB,CAAC;QAAEC;MAAF,CAAD,CAAvC;IACD;EACF;;EAED,OAAOe,cAAP;AACD,CAhCM;;;;AAkCA,MAAMI,0BAA0B,GAAG,CAAC;EACzCC,SADyC;EAEzCC,iBAFyC;EAGzCN,cAAc,GAAI,EAHuB;EAIzCO,cAAc,GAAI,EAJuB;EAKzCC,cAAc,GAAI;AALuB,CAAD,KAOxCC,UAAU,CAAC;EACTC,SAAS,EAAG,iBADH;EAETC,SAAS,EAAG,iCAAgCJ,cAAe,EAFlD;EAGTF,SAHS;EAITG,cAAc,EAAG,iCAAgCA,cAAe,EAJvD;EAKTF,iBAAiB,EAAG;AACxB;AACA,YAAYA,iBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,OAba;EAcTN;AAdS,CAAD,CAPL;;;;AAwBP,MAAMY,cAAc,GAAGD,SAAS,IAC9BA,SAAS,IAAI,OAAOA,SAAP,KAAsB,QAAnC,GAA8C,IAAGA,SAAU,GAA3D,GAAiE,EADnE;;AAGA,MAAME,mBAAmB,GAAG,CAAC;EAAExB,IAAF;EAAQE,MAAR;EAAgBN;AAAhB,CAAD,KAAkC;AAC9D,WAAWI,IAAK;AAChB,MAAMI,iBAAiB,CAACF,MAAD,EAAS;EAAEN;AAAF,CAAT,CAAwB;AAC/C;AACA,CAJA;;AAMA,MAAMS,oBAAoB,GAAG,CAACF,eAAD,EAAkB;EAAEP,SAAS,GAAG;AAAd,IAAqB,EAAvC,KAC3BO,eAAe,GACV;AACP;AACA,QAAQA,eAAe,CACdJ,GADD,CACK0B,cAAc,IACjBD,mBAAmB,CAAC,EAAE,GAAGC,cAAL;EAAqB7B;AAArB,CAAD,CAFrB,EAICU,IAJD,CAIO,GAJP,CAIW;AACnB,KARiB,GASV,EAVP;;AAYO,MAAMF,iBAAiB,GAAG,CAC/BF,MAD+B,EAE/B;EAAEN,SAAS,GAAG,EAAd;EAAkB8B,0BAA0B,GAAG;AAA/C,IAAsD,EAFvB,KAG5B;EACH,IAAI,CAACxB,MAAD,IAAW,CAACA,MAAM,CAACQ,MAAvB,EAA+B;IAC7B,OAAQ,EAAR;EACD;;EAED,MAAM;IACJiB,YAAY,EAAE;MAAEC;IAAF;EADV,IAEFC,cAAA,CAAMC,QAAN,EAFJ;;EAIA,MAAMC,sBAAsB,GAAGC,KAAK,IAAI;IACtC,IAAI,OAAOA,KAAP,KAAkB,QAAtB,EAA+B;MAC7B,OAAOA,KAAP;IACD;;IAED,IAAI;MACFhB,SADE;MAEFM,SAFE;MAGFpB,MAHE;MAIFC,eAJE;MAKF8B,SALE;MAMFC,YANE;MAOFjB;IAPE,IAQAe,KARJ;;IAUA,IAAIE,YAAY,KAAM,UAAtB,EAAiC;MAC/B,OAAQ,MAAKF,KAAK,CAACG,QAAN,CAAenC,IAAK,EAAjC;IACD;;IAED,IACE,CAAC,CAACsB,SAAD,IAAcA,SAAS,KAAM,EAA9B,KACApB,MADA,aACAA,MADA,eACAA,MAAM,CAAEkC,IAAR,CAAaJ,KAAK,IAAIA,KAAK,CAAChB,SAAN,KAAqB,OAA3C,CAFF,EAGE;MACA;MACA;MACAM,SAAS,GAAI,YAAb;IACD;;IAED,MAAMd,YAAY,GAChBS,iBAAiB,IACjBb,iBAAiB,CAACF,MAAD,EAAS;MACxBN;IADwB,CAAT,CAFnB;IAMA,MAAMyC,oBAAoB,GAAGhC,oBAAoB,CAACF,eAAD,EAAkB;MACjEP;IADiE,CAAlB,CAAjD;;IAIA,IAAIoB,SAAS,KAAKqB,oBAAoB,KAAM,EAA1B,IAA+B7B,YAAY,KAAM,EAAtD,CAAb,EAAuE;MACrE,OAAQ;AACd,UAAUQ,SAAU,IAAGO,cAAc,CAACD,SAAD,CAAY;AACjD,YAAYd,YAAa;AACzB,YAAY6B,oBAAqB;AACjC;AACA,OALM;IAMD,CAPD,MAOO,IAAIrB,SAAJ,EAAe;MACpB,MAAMsB,aAAa,GAAGV,OAAO,CAACW,GAAR,CAAY,IAAAC,0BAAA,EAAkBP,SAAlB,CAAZ,CAAtB,CADoB,CAGpB;MACA;MACA;;MACA,IAAIK,aAAa,CAACpC,MAAlB,EAA0B;QACxB,OAAO,IAAP;MACD;;MAED,OAAOc,SAAP;IACD;;IAED,OAAO,IAAP;EACD,CA3DD;;EA6DA,IAAIyB,2BAA2B,GAAI,EAAnC;;EAEA,IAAIf,0BAAJ,aAAIA,0BAAJ,eAAIA,0BAA0B,CAAEhB,MAAhC,EAAwC;IACtC+B,2BAA2B,GAAGf,0BAA0B,CAAC3B,GAA3B,CAC5B0B,cAAc,IAAK,UAASA,cAAc,CAACzB,IAAK;AACtD,UAAUyB,cAAc,CAACvB,MAAf,CAAsBH,GAAtB,CAA0BgC,sBAA1B,EAAkDW,MAAlD,CAAyDC,OAAzD,EACCrC,IADD,CACO;AACjB,SAFU,CAEC;AACX,QALkC,CAA9B;EAOD;;EAED,MAAME,YAAY,GAAGN,MAAM,CAACH,GAAP,CAAWgC,sBAAX,EAAmCW,MAAnC,CAA0CC,OAA1C,EAAmDrC,IAAnD,CAAyD;AAChF,KADuB,CAArB;EAGA,OAAQ,GAAEmC,2BAA4B,IAAGjC,YAAa,EAAtD;AACD,CAzFM;;;;AA2FP,MAAMY,UAAU,GAAG,CAAC;EAClBC,SADkB;EAElBL,SAFkB;EAGlBG,cAHkB;EAIlBG,SAJkB;EAKlBL,iBALkB;EAMlBN,cAAc,GAAI;AANA,CAAD,KAOZ;AACP,UAAUU,SAAU,IAAGE,cAAc,CAACD,SAAD,CAAY;AACjD,MAAMN,SAAU,IAAGO,cAAc,CAACJ,cAAD,CAAiB;AAClD,QAAQF,iBAAkB;AAC1B;AACA;AACA;AACA,IAAIN,cAAe;AACnB,CAfA;;AAiBO,MAAMiC,yBAAyB,GAAG,CAAC;EACxC5B,SADwC;EAExCL,cAFwC;EAGxCM,iBAHwC;EAIxCK,SAAS,GAAI,UAJ2B;EAKxCuB,mBAAmB,GAAI,SALiB;EAMxCxB,SAAS,GAAI;AAN2B,CAAD,KAQvCD,UAAU,CAAC;EACTC,SADS;EAETC,SAFS;EAGTN,SAHS;EAITG,cAAc,EAAE0B,mBAJP;EAKTlC,cALS;EAMTM;AANS,CAAD,CARL"}