{"version":3,"file":"generate-queries-from-ingestable-types.js","names":["recursivelyAliasFragments","field","inlineFragments","map","fragment","fields","fragmentField","updatedFragmentField","forEach","possiblyConflictingFragment","name","possiblyConflictingField","fieldNamesMatch","fieldName","fieldTypeKindsDontMatch","fieldType","kind","fieldTypeNamesDontMatch","autoAliasedFieldName","aliasConflictingFieldFields","aliasConflictingFields","transformedFields","aliasConflictingFragmentFields","fragments","fragmentKey","Object","entries","aliasedFragment","generateNodeQueriesFromIngestibleFields","remoteSchema","gatsbyApi","helpers","reporter","pluginOptions","debug","graphql","copyNodeSourcingQueryAndExit","store","getState","fieldBlacklist","nodeListFilter","typeMap","ingestibles","nodeListRootFields","rootFields","get","nodeQueries","type","includes","fieldFields","nodesField","find","nodesType","findNamedTypeName","panic","formatLogMessage","possibleTypes","settings","getTypeSettingsByType","exclude","nodeListQueries","singleNodeRootFieldInfo","warn","singleFieldName","recursivelyTransformFields","parentType","mainType","push","transformedInlineFragments","transformInlineFragments","buildGatsbyNodeFields","inlineFragment","aliasedTransformedFields","selectionSet","buildSelectionSet","fieldPath","builtFragments","generateReusableFragments","nodeQuery","buildNodeQueryOnFieldName","builtSelectionSet","previewQuery","fieldInputArguments","queryName","fieldVariables","where","queries","buildNodesQueryOnFieldName","length","nodeListQuery","process","env","NODE_ENV","log","clipboardy","write","prettier","format","parser","exit","e","error","typeInfo","singularName","pluralName","nodesTypeName"],"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/generate-queries-from-ingestable-types.js"],"sourcesContent":["import recursivelyTransformFields, {\n  transformInlineFragments,\n} from \"./recursively-transform-fields\"\n\nimport {\n  buildNodesQueryOnFieldName,\n  buildNodeQueryOnFieldName,\n  buildSelectionSet,\n  generateReusableFragments,\n} from \"./build-query-on-field-name\"\n\nimport clipboardy from \"clipboardy\"\n\nimport store from \"~/store\"\nimport { getTypeSettingsByType } from \"~/steps/create-schema-customization/helpers\"\nimport prettier from \"prettier\"\nimport { formatLogMessage } from \"~/utils/format-log-message\"\nimport { findNamedTypeName } from \"../../create-schema-customization/helpers\"\n\nconst recursivelyAliasFragments = field =>\n  field.inlineFragments.map(fragment => {\n    // for each of this inlineFragments fields\n    fragment.fields = fragment.fields.map(fragmentField => {\n      if (typeof fragmentField === `string`) {\n        return fragmentField\n      }\n\n      // compare it against each field of each other fragment\n      let updatedFragmentField = fragmentField\n\n      field.inlineFragments.forEach(possiblyConflictingFragment => {\n        // don't compare this fragment against itself\n        if (possiblyConflictingFragment.name === fragment.name) {\n          return\n        }\n\n        possiblyConflictingFragment.fields.forEach(possiblyConflictingField => {\n          const fieldNamesMatch =\n            fragmentField.fieldName === possiblyConflictingField.fieldName\n\n          const fieldTypeKindsDontMatch =\n            possiblyConflictingField?.fieldType?.kind !==\n            fragmentField?.fieldType?.kind\n\n          const fieldTypeNamesDontMatch =\n            possiblyConflictingField?.fieldType?.name !==\n            fragmentField?.fieldType?.name\n\n          // if the fields have the same name but a different type kind\n          // alias them\n          if (\n            fieldNamesMatch &&\n            (fieldTypeKindsDontMatch || fieldTypeNamesDontMatch)\n          ) {\n            const autoAliasedFieldName = `${fragmentField.fieldName}__typename_${fragmentField.fieldType.name}: ${fragmentField.fieldName}`\n\n            updatedFragmentField = {\n              ...fragmentField,\n              fieldName: autoAliasedFieldName,\n            }\n\n            return\n          }\n        })\n      })\n      // if the fields have the same name but a different type AND the field has sub fields, compare those sub fields against any fragment fields subfields where the field name matches\n      // if any subfields have conflicting types, alias them\n\n      if (updatedFragmentField.inlineFragments) {\n        updatedFragmentField.inlineFragments =\n          recursivelyAliasFragments(updatedFragmentField)\n      }\n\n      return updatedFragmentField\n    })\n\n    return fragment\n  })\n\nconst aliasConflictingFieldFields = field => {\n  // we only have conflicting fields in inlineFragments\n  // if there are no inlineFragments, do nothing\n  if (!field.inlineFragments) {\n    return field\n  }\n\n  field.inlineFragments = recursivelyAliasFragments(field)\n\n  if (field.fields) {\n    field.fields = aliasConflictingFields({\n      transformedFields: field.fields,\n    })\n  }\n\n  return field\n}\n\nconst aliasConflictingFields = ({ transformedFields }) =>\n  transformedFields.map(aliasConflictingFieldFields)\n\nconst aliasConflictingFragmentFields = ({ fragments }) => {\n  for (const [fragmentKey, fragment] of Object.entries(fragments)) {\n    const aliasedFragment = aliasConflictingFieldFields(fragment)\n\n    fragments[fragmentKey] = aliasedFragment\n  }\n}\n\n/**\n * generateNodeQueriesFromIngestibleFields\n *\n * Takes in data from an introspection query and\n * processes it to build GraphQL query strings/info\n *\n * @param {object} introspectionData\n * @returns {Object} GraphQL query info including gql query strings\n */\nconst generateNodeQueriesFromIngestibleFields = async () => {\n  const {\n    remoteSchema,\n    gatsbyApi: {\n      helpers: { reporter },\n      pluginOptions: {\n        debug: {\n          graphql: { copyNodeSourcingQueryAndExit },\n        },\n      },\n    },\n  } = store.getState()\n\n  const {\n    fieldBlacklist,\n    nodeListFilter,\n    typeMap,\n    ingestibles: { nodeListRootFields },\n  } = remoteSchema\n\n  const rootFields = typeMap.get(`RootQuery`).fields\n\n  const nodeQueries = {}\n\n  for (const { type, name } of nodeListRootFields) {\n    if (fieldBlacklist.includes(name)) {\n      continue\n    }\n\n    // nested fields\n    const fieldFields = typeMap.get(type.name).fields\n\n    // a nested field containing a list of nodes\n    const nodesField = fieldFields.find(nodeListFilter)\n\n    // the type of this query\n    const nodesType = typeMap.get(findNamedTypeName(nodesField.type))\n\n    if (!nodesType) {\n      reporter.panic(\n        formatLogMessage(\n          `Couldn't infer node type in the remote schema from the ${name} root field.`\n        )\n      )\n    }\n\n    const { fields, possibleTypes } = nodesType\n\n    const settings = getTypeSettingsByType(nodesType)\n\n    if (settings.exclude) {\n      continue\n    }\n\n    let nodeListQueries = []\n\n    const singleNodeRootFieldInfo = rootFields.find(\n      field => field.type.name === nodesType.name\n    )\n\n    if (!singleNodeRootFieldInfo) {\n      // @todo handle cases where there is a nodelist field but no individual field. we can't do data updates or preview on this type.\n      reporter.warn(\n        formatLogMessage(\n          `Unable to find a single Node query for ${nodesType.name}\\n\\tThis type will not be available in Gatsby.\\n`\n        )\n      )\n      continue\n    }\n\n    const fragments = {}\n\n    const singleFieldName = singleNodeRootFieldInfo?.name\n\n    const transformedFields = recursivelyTransformFields({\n      fields,\n      fragments,\n      parentType: type,\n      mainType: type,\n    })\n\n    // we need this for node interface types on the WPGQL side\n    transformedFields.push(`__typename`)\n\n    let transformedInlineFragments\n\n    if (possibleTypes) {\n      transformedInlineFragments = transformInlineFragments({\n        possibleTypes,\n        fragments,\n        parentType: nodesType,\n        mainType: nodesType,\n        debug: true,\n        // normally we only want the id for gatsby node fields\n        // but in this case we're at the top level and need to query\n        // these fields\n        buildGatsbyNodeFields: true,\n      })\n\n      // alias conflicting inline fragment fields\n      transformedInlineFragments = transformedInlineFragments.map(\n        ({ fields, ...inlineFragment }) => {\n          return {\n            ...inlineFragment,\n            fields: aliasConflictingFields({\n              transformedFields: fields,\n            }),\n          }\n        }\n      )\n    }\n\n    // mutates the fragments..\n    aliasConflictingFragmentFields({ fragments })\n\n    const aliasedTransformedFields = aliasConflictingFields({\n      transformedFields,\n      parentType: type,\n    })\n\n    const selectionSet = buildSelectionSet(aliasedTransformedFields, {\n      fieldPath: name,\n      fragments,\n      transformedInlineFragments,\n    })\n\n    const builtFragments = generateReusableFragments({\n      fragments,\n      selectionSet,\n    })\n\n    const nodeQuery = buildNodeQueryOnFieldName({\n      fields: transformedFields,\n      fieldName: singleFieldName,\n      settings,\n      builtFragments,\n      builtSelectionSet: selectionSet,\n    })\n\n    const previewQuery = buildNodeQueryOnFieldName({\n      fields: transformedFields,\n      fieldName: singleFieldName,\n      fieldInputArguments: `id: $id, idType: ID, asPreview: true`,\n      queryName: `PREVIEW_QUERY`,\n      settings,\n      builtFragments,\n      builtSelectionSet: selectionSet,\n    })\n\n    const fieldVariables = settings.where ? `where: { ${settings.where} }` : ``\n\n    if (\n      settings.nodeListQueries &&\n      typeof settings.nodeListQueries === `function`\n    ) {\n      const queries = settings.nodeListQueries({\n        name,\n        fields,\n        selectionSet,\n        builtFragments,\n        singleFieldName,\n        singleNodeRootFieldInfo,\n        settings,\n        store,\n        fieldVariables,\n        remoteSchema,\n        transformedFields,\n        helpers: {\n          recursivelyTransformFields,\n          buildNodesQueryOnFieldName,\n        },\n      })\n\n      if (queries && queries.length) {\n        nodeListQueries = queries\n      }\n    }\n\n    if (!nodeListQueries || !nodeListQueries.length) {\n      const nodeListQuery = buildNodesQueryOnFieldName({\n        fields: transformedFields,\n        fieldName: name,\n        fieldVariables,\n        settings,\n        builtFragments,\n        builtSelectionSet: selectionSet,\n      })\n\n      nodeListQueries = [nodeListQuery]\n    }\n\n    if (\n      process.env.NODE_ENV === `development` &&\n      nodesType.name === copyNodeSourcingQueryAndExit\n    ) {\n      try {\n        reporter.log(``)\n        reporter.warn(\n          formatLogMessage(\n            `Query debug mode. Writing node list query for the ${nodesType.name} node type to the system clipboard and exiting\\n\\n`\n          )\n        )\n        await clipboardy.write(\n          prettier.format(nodeListQueries[0], { parser: `graphql` })\n        )\n        process.exit()\n      } catch (e) {\n        reporter.log(``)\n        reporter.error(e)\n        reporter.log(``)\n        reporter.warn(\n          formatLogMessage(\n            `Query debug mode failed. There was a failed attempt to copy the query for the ${nodesType.name} node type to your clipboard.\\n\\n`\n          )\n        )\n        reporter.error(e)\n      }\n    }\n\n    // build a query info object containing gql query strings for fetching\n    // node lists or single nodes, as well as type info and plugin\n    // settings for this type\n    nodeQueries[name] = {\n      typeInfo: {\n        singularName: singleFieldName,\n        pluralName: name,\n        nodesTypeName: nodesType.name,\n      },\n      nodeListQueries,\n      nodeQuery,\n      previewQuery,\n      selectionSet,\n      builtFragments,\n      settings,\n    }\n  }\n\n  return nodeQueries\n}\n\nexport default generateNodeQueriesFromIngestibleFields\n"],"mappings":"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"}