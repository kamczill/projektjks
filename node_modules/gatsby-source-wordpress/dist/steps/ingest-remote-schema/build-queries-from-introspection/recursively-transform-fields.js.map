{"version":3,"file":"recursively-transform-fields.js","names":["transformInlineFragments","possibleTypes","gatsbyNodesInfo","typeMap","maxDepth","parentType","mainType","parentField","fragments","circularQueryLimit","buildGatsbyNodeFields","depth","buildingFragment","ancestorTypeNames","parentAncestorTypeNames","state","store","getState","remoteSchema","pluginOptions","gatsbyApi","schema","queryDepth","transformedInlineFragments","map","possibleType","type","get","name","typeSettings","getTypeSettingsByType","exclude","dispatch","addFetchedType","isAGatsbyNode","typeNames","includes","fields","typeInfo","filteredFields","kind","filter","filteredField","find","recursivelyTransformFields","length","Boolean","countIncarnations","typeName","ancestorTypeName","transformField","field","fieldBlacklist","fieldAliases","findNamedTypeName","typeKind","findTypeKind","typeIncarnationCount","createFragment","fieldName","returnAliasedFieldName","args","arg","fieldType","ofType","isListOfGatsbyNodes","isListOfMediaItems","hasIdField","listOfType","transformedFields","inlineFragments","every","parentFieldName","previouslyCreatedFragment","fragmentFields","reduce","fieldTypeName","innerFieldField","transformedField","push","queryType","transformFields","fieldIsExcludedOnParentType","fieldIsExcludedOnAll","fragment","fragmentField","internalType","fieldInlineFragment","fragmentInlineFragment","fieldTypeKind","fieldOfTypeKind","typeKindsRequiringSelectionSets","fieldNeedsSelectionSet","grandParentTypeName","recursivelyTransformedFields"],"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/recursively-transform-fields.js"],"sourcesContent":["import store from \"~/store\"\nimport {\n  getTypeSettingsByType,\n  findNamedTypeName,\n  findTypeKind,\n} from \"~/steps/create-schema-customization/helpers\"\nimport {\n  fieldIsExcludedOnParentType,\n  fieldIsExcludedOnAll,\n} from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { returnAliasedFieldName } from \"~/steps/create-schema-customization/transform-fields\"\n\nexport const transformInlineFragments = ({\n  possibleTypes,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  parentType,\n  mainType,\n  parentField,\n  fragments,\n  circularQueryLimit,\n  buildGatsbyNodeFields = false,\n  depth = 0,\n  buildingFragment = false,\n  ancestorTypeNames: parentAncestorTypeNames = [],\n}) => {\n  const state = store.getState()\n\n  if (!typeMap) {\n    typeMap = state.remoteSchema.typeMap\n  }\n\n  const { pluginOptions } = state.gatsbyApi\n\n  if (!maxDepth) {\n    maxDepth = pluginOptions.schema.queryDepth\n  }\n\n  if (!circularQueryLimit) {\n    circularQueryLimit = pluginOptions.circularQueryLimit\n  }\n\n  if (!gatsbyNodesInfo) {\n    gatsbyNodesInfo = state.remoteSchema.gatsbyNodesInfo\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const transformedInlineFragments = possibleTypes\n    .map(possibleType => {\n      possibleType = { ...possibleType }\n\n      const type = typeMap.get(possibleType.name)\n\n      if (!type) {\n        return false\n      }\n\n      const typeSettings = getTypeSettingsByType(type)\n\n      if (typeSettings.exclude) {\n        return false\n      }\n\n      possibleType.type = { ...type }\n\n      // save this type so we can use it in schema customization\n      store.dispatch.remoteSchema.addFetchedType(type)\n\n      const isAGatsbyNode = gatsbyNodesInfo.typeNames.includes(\n        possibleType.name\n      )\n\n      if (isAGatsbyNode && !buildGatsbyNodeFields) {\n        // we use the id to link to the top level Gatsby node\n        possibleType.fields = [`id`]\n        return possibleType\n      }\n\n      const typeInfo = typeMap.get(possibleType.name)\n\n      let filteredFields = [...typeInfo.fields]\n\n      if (parentType?.kind === `INTERFACE`) {\n        // remove any fields from our fragment if the parent type already has them as shared fields\n        filteredFields = filteredFields.filter(\n          filteredField =>\n            !parentType.fields.find(\n              parentField => parentField.name === filteredField.name\n            )\n        )\n      }\n\n      if (typeInfo) {\n        const fields = recursivelyTransformFields({\n          fields: filteredFields,\n          parentType: type,\n          depth,\n          ancestorTypeNames,\n          fragments,\n          buildingFragment,\n          circularQueryLimit,\n          mainType,\n          parentField,\n        })\n\n        if (!fields || !fields.length) {\n          return false\n        }\n\n        possibleType.fields = [...fields]\n        return possibleType\n      }\n\n      return false\n    })\n    .filter(Boolean)\n\n  return possibleTypes && depth <= maxDepth ? transformedInlineFragments : null\n}\n\n// since we're counting circular types that may be on fields many levels up, incarnation felt like it works here ;) the types are born again in later generations\nconst countIncarnations = ({ typeName, ancestorTypeNames }) =>\n  ancestorTypeNames.length\n    ? ancestorTypeNames.filter(\n        ancestorTypeName => ancestorTypeName === typeName\n      )?.length\n    : 0\n\nexport function transformField({\n  field,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  ancestorTypeNames: parentAncestorTypeNames,\n  circularQueryLimit,\n  fragments,\n  buildingFragment,\n  mainType,\n} = {}) {\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  // we're potentially infinitely recursing when fields are connected to other types that have fields that are connections to other types\n  //  so we need a maximum limit for that\n  if (depth > maxDepth) {\n    return false\n  }\n\n  depth++\n\n  // if the field has no type we can't use it.\n  if (!field || !field.type) {\n    return false\n  }\n\n  const typeSettings = getTypeSettingsByType(field.type)\n\n  if (typeSettings.exclude) {\n    return false\n  }\n\n  // count the number of times this type has appeared as an ancestor of itself\n  // somewhere up the tree\n  const typeName = findNamedTypeName(field.type)\n  const typeKind = findTypeKind(field.type)\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount > 0) {\n    // this type is nested within itself atleast once\n    // create a fragment here that can be reused\n    createFragment({\n      fields: typeMap.get(typeName).fields,\n      type: field.type,\n      fragments,\n      field,\n      ancestorTypeNames: parentAncestorTypeNames,\n      depth,\n      fieldBlacklist,\n      fieldAliases,\n      typeMap,\n      gatsbyNodesInfo,\n      circularQueryLimit,\n      queryDepth: maxDepth,\n      buildingFragment,\n      mainType,\n    })\n  }\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return false\n  }\n\n  // this is used to alias fields that conflict with Gatsby node fields\n  // for ex Gatsby and WPGQL both have a `parent` field\n  const fieldName = returnAliasedFieldName({ fieldAliases, field })\n\n  if (\n    fieldBlacklist.includes(field.name) ||\n    fieldBlacklist.includes(fieldName)\n  ) {\n    return false\n  }\n\n  // remove fields that have required args. They'll cause query errors if omitted\n  //  and we can't determine how to use those args programatically.\n  if (\n    field.args &&\n    field.args.length &&\n    field.args.find(arg => arg?.type?.kind === `NON_NULL`)\n  ) {\n    return false\n  }\n\n  const fieldType = typeMap.get(findNamedTypeName(field.type)) || {}\n  const ofType = typeMap.get(findNamedTypeName(fieldType.ofType)) || {}\n\n  if (\n    fieldType.kind === `SCALAR` ||\n    fieldType.kind === `ENUM` ||\n    (fieldType.kind === `NON_NULL` && ofType.kind === `SCALAR`) ||\n    (fieldType.kind === `LIST` && fieldType.ofType.kind === `SCALAR`) ||\n    // a list of enums has no type name, so findNamedTypeName above finds the enum type\n    // instead of the field type. Need to explicitly check here\n    // instead of using helpers\n    (field.type.kind === `LIST` && field.type?.ofType?.kind === `ENUM`)\n  ) {\n    return {\n      fieldName,\n      fieldType,\n    }\n  }\n\n  const isListOfGatsbyNodes =\n    ofType && gatsbyNodesInfo.typeNames.includes(typeName)\n\n  const isListOfMediaItems = ofType && typeName === `MediaItem`\n\n  const hasIdField = fieldType?.fields?.find(({ name }) => name === `id`)\n  if (\n    fieldType.kind === `LIST` &&\n    isListOfGatsbyNodes &&\n    !isListOfMediaItems &&\n    hasIdField\n  ) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST` && isListOfMediaItems && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST`) {\n    const listOfType = typeMap.get(findNamedTypeName(fieldType))\n\n    const transformedFields = recursivelyTransformFields({\n      fields: listOfType.fields,\n      parentType: listOfType || fieldType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n      mainType,\n    })\n\n    const transformedInlineFragments = transformInlineFragments({\n      possibleTypes: listOfType.possibleTypes,\n      parentType: listOfType || fieldType,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    // if we have either inlineFragments or fields\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  const isAGatsbyNode =\n    // if this is a gatsby node type\n    gatsbyNodesInfo.typeNames.includes(typeName) ||\n    // or all possible types on this type are Gatsby node types\n    typeMap\n      .get(typeName)\n      ?.possibleTypes?.every(possibleType =>\n        gatsbyNodesInfo.typeNames.includes(possibleType.name)\n      )\n\n  if (isAGatsbyNode && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  }\n\n  const typeInfo = typeMap.get(findNamedTypeName(fieldType))\n\n  const { fields } = typeInfo || {}\n\n  let transformedInlineFragments\n\n  if (typeInfo.possibleTypes) {\n    transformedInlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      parentType: typeInfo,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n  }\n\n  if (fields || transformedInlineFragments) {\n    const transformedFields = recursivelyTransformFields({\n      parentType: typeInfo,\n      parentFieldName: field.name,\n      mainType,\n      fields,\n      depth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  if (fieldType.kind === `UNION`) {\n    const typeInfo = typeMap.get(fieldType.name)\n\n    const transformedFields = recursivelyTransformFields({\n      fields: typeInfo.fields,\n      parentType: fieldType,\n      mainType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    const inlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      gatsbyNodesInfo,\n      typeMap,\n      mainType,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments,\n      fieldType,\n    }\n  }\n\n  return false\n}\n\nconst createFragment = ({\n  fields,\n  field,\n  type,\n  fragments,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  ancestorTypeNames,\n  mainType,\n  buildingFragment = false,\n}) => {\n  const typeName = findNamedTypeName(type)\n\n  if (buildingFragment) {\n    // this fragment is inside a fragment that's already being built so we should exit\n    return null\n  }\n\n  const previouslyCreatedFragment = fragments?.[typeName]\n\n  if (previouslyCreatedFragment && buildingFragment === typeName) {\n    return previouslyCreatedFragment\n  }\n\n  const fragmentFields = fields.reduce((fragmentFields, field) => {\n    const fieldTypeName = findNamedTypeName(field.type)\n    const fieldType = typeMap.get(fieldTypeName)\n\n    if (\n      // if this field is a different type than the fragment but has a field of the same type as the fragment,\n      // we need to skip this field in the fragment to prevent nesting this type in itself a level down\n      fieldType.name !== typeName &&\n      fieldType?.fields?.find(\n        innerFieldField => findNamedTypeName(innerFieldField.type) === typeName\n      )\n    ) {\n      return fragmentFields\n    }\n\n    const transformedField = transformField({\n      field,\n      gatsbyNodesInfo,\n      typeMap,\n      maxDepth: queryDepth,\n      depth: 0,\n      fieldBlacklist,\n      fieldAliases,\n      ancestorTypeNames,\n      mainType,\n      circularQueryLimit: 1,\n      fragments,\n      buildingFragment: typeName,\n    })\n\n    if (findNamedTypeName(field.type) !== typeName && !!transformedField) {\n      fragmentFields.push(transformedField)\n    }\n\n    return fragmentFields\n  }, [])\n\n  const queryType = typeMap.get(typeName)\n\n  const transformedInlineFragments = queryType?.possibleTypes?.length\n    ? transformInlineFragments({\n        possibleTypes: queryType.possibleTypes,\n        parentType: queryType,\n        parentField: field,\n        mainType,\n        gatsbyNodesInfo,\n        typeMap,\n        depth: 0,\n        maxDepth: queryDepth,\n        circularQueryLimit: 1,\n        ancestorTypeNames,\n        fragments,\n        buildingFragment: typeName,\n      })\n    : null\n\n  if (fragments) {\n    fragments[typeName] = {\n      name: `${typeName}Fragment`,\n      type: typeName,\n      fields: fragmentFields,\n      inlineFragments: transformedInlineFragments,\n    }\n  }\n\n  return fragmentFields\n}\n\nconst transformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  circularQueryLimit,\n  pluginOptions,\n  buildingFragment,\n}) =>\n  fields\n    ?.filter(\n      field =>\n        !fieldIsExcludedOnParentType({\n          field,\n          parentType,\n        }) &&\n        !fieldIsExcludedOnAll({\n          pluginOptions,\n          field,\n        })\n    )\n    .map(field => {\n      const transformedField = transformField({\n        maxDepth: queryDepth,\n        gatsbyNodesInfo,\n        fieldBlacklist,\n        fieldAliases,\n        typeMap,\n        field,\n        depth,\n        ancestorTypeNames,\n        circularQueryLimit,\n        fragments,\n        buildingFragment,\n        mainType,\n        parentField,\n      })\n\n      if (transformedField) {\n        // save this type so we know to use it in schema customization\n        store.dispatch.remoteSchema.addFetchedType(field.type)\n      }\n\n      const typeName = findNamedTypeName(field.type)\n      const fragment = fragments?.[typeName]\n\n      // @todo add any adjacent fields and inline fragments directly to the stored fragment object so this logic can be changed to if (fragment) useTheFragment()\n      // once that's done it can be added above and below transformField() above ☝️\n      // and potentially short circuit expensive work that will be thrown away anyway\n      if (fragment && transformedField && buildingFragment !== typeName) {\n        // if (fragment && buildingFragment !== typeName && transformedField) {\n        // remove fields from this query that already exist in the fragment\n        if (transformedField?.fields?.length) {\n          transformedField.fields = transformedField.fields.filter(\n            field =>\n              !fragment.fields.find(\n                fragmentField => fragmentField.fieldName === field.fieldName\n              )\n          )\n        }\n\n        // if this field has no fields (because it has inline fragments only)\n        // we need to create an empty array since we treat reusable fragments as\n        // a field\n        if (!transformedField.fields) {\n          transformedField.fields = []\n        }\n\n        transformedField.fields.push({\n          internalType: `Fragment`,\n          fragment,\n        })\n\n        if (transformedField?.inlineFragments?.length) {\n          transformedField.inlineFragments =\n            transformedField.inlineFragments.filter(\n              fieldInlineFragment =>\n                // yes this is a horrible use of .find(). @todo refactor this for better perf\n                !fragment.inlineFragments.find(\n                  fragmentInlineFragment =>\n                    fragmentInlineFragment.name === fieldInlineFragment.name\n                )\n            )\n        }\n      }\n\n      if (field.fields && !transformedField) {\n        return null\n      }\n\n      const fieldTypeKind = findTypeKind(field.type)\n      const fieldOfTypeKind = findTypeKind(field.type.ofType)\n      const typeKindsRequiringSelectionSets = [`OBJECT`, `UNION`, `INTERFACE`]\n      const fieldNeedsSelectionSet =\n        typeKindsRequiringSelectionSets.includes(fieldTypeKind) ||\n        typeKindsRequiringSelectionSets.includes(fieldOfTypeKind)\n\n      if (\n        // if our field needs a selectionset\n        fieldNeedsSelectionSet &&\n        // but we have no fields\n        !transformedField.fields &&\n        // and no inline fragments\n        !transformedField.inlineFragments\n      ) {\n        // we need to discard this field to prevent GraphQL errors\n        // we're likely at the very bottom of the query depth\n        // so that this fields children were omitted\n        return null\n      }\n\n      return transformedField\n    })\n    .filter(Boolean)\n\nconst recursivelyTransformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames: parentAncestorTypeNames,\n  depth = 0,\n  buildingFragment = false,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  if (!parentAncestorTypeNames) {\n    parentAncestorTypeNames = []\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const {\n    gatsbyApi: { pluginOptions },\n    remoteSchema: { fieldBlacklist, fieldAliases, typeMap, gatsbyNodesInfo },\n  } = store.getState()\n\n  const {\n    schema: { queryDepth, circularQueryLimit },\n  } = pluginOptions\n\n  if (depth > queryDepth && ancestorTypeNames.length) {\n    return null\n  }\n\n  const typeName = findNamedTypeName(parentType)\n\n  const grandParentTypeName = ancestorTypeNames.length\n    ? ancestorTypeNames[ancestorTypeNames.length - 1]\n    : null\n\n  if (grandParentTypeName && typeName !== grandParentTypeName) {\n    // if a field has fields of the same type as the field above it\n    // we shouldn't fetch them. 2 types that are circular between each other\n    // are dangerous as they will generate very large queries and fetch data we don't need\n    // these types should instead be proper connections so we can identify\n    // that only an id needs to be fetched.\n    // @todo maybe move this into transformFields() instead of here\n    fields = fields.filter(field => {\n      const fieldTypeName = findNamedTypeName(field.type)\n      return fieldTypeName !== grandParentTypeName\n    })\n  }\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return null\n  }\n\n  parentAncestorTypeNames.push(typeName)\n\n  const recursivelyTransformedFields = transformFields({\n    fields,\n    parentType,\n    mainType,\n    fragments,\n    parentField,\n    ancestorTypeNames: parentAncestorTypeNames,\n    depth,\n    fieldBlacklist,\n    fieldAliases,\n    typeMap,\n    gatsbyNodesInfo,\n    queryDepth,\n    circularQueryLimit,\n    pluginOptions,\n    buildingFragment,\n  })\n\n  if (!recursivelyTransformedFields.length) {\n    return null\n  }\n\n  return recursivelyTransformedFields\n}\n\nexport default recursivelyTransformFields\n"],"mappings":";;;;;;;;;AAAA;;AACA;;AAKA;;AAIA;;AAEO,MAAMA,wBAAwB,GAAG,CAAC;EACvCC,aADuC;EAEvCC,eAFuC;EAGvCC,OAHuC;EAIvCC,QAJuC;EAKvCC,UALuC;EAMvCC,QANuC;EAOvCC,WAPuC;EAQvCC,SARuC;EASvCC,kBATuC;EAUvCC,qBAAqB,GAAG,KAVe;EAWvCC,KAAK,GAAG,CAX+B;EAYvCC,gBAAgB,GAAG,KAZoB;EAavCC,iBAAiB,EAAEC,uBAAuB,GAAG;AAbN,CAAD,KAclC;EACJ,MAAMC,KAAK,GAAGC,cAAA,CAAMC,QAAN,EAAd;;EAEA,IAAI,CAACd,OAAL,EAAc;IACZA,OAAO,GAAGY,KAAK,CAACG,YAAN,CAAmBf,OAA7B;EACD;;EAED,MAAM;IAAEgB;EAAF,IAAoBJ,KAAK,CAACK,SAAhC;;EAEA,IAAI,CAAChB,QAAL,EAAe;IACbA,QAAQ,GAAGe,aAAa,CAACE,MAAd,CAAqBC,UAAhC;EACD;;EAED,IAAI,CAACb,kBAAL,EAAyB;IACvBA,kBAAkB,GAAGU,aAAa,CAACV,kBAAnC;EACD;;EAED,IAAI,CAACP,eAAL,EAAsB;IACpBA,eAAe,GAAGa,KAAK,CAACG,YAAN,CAAmBhB,eAArC;EACD;;EAED,MAAMW,iBAAiB,GAAG,CAAC,GAAGC,uBAAJ,CAA1B;EAEA,MAAMS,0BAA0B,GAAGtB,aAAa,CAC7CuB,GADgC,CAC5BC,YAAY,IAAI;IACnBA,YAAY,GAAG,EAAE,GAAGA;IAAL,CAAf;IAEA,MAAMC,IAAI,GAAGvB,OAAO,CAACwB,GAAR,CAAYF,YAAY,CAACG,IAAzB,CAAb;;IAEA,IAAI,CAACF,IAAL,EAAW;MACT,OAAO,KAAP;IACD;;IAED,MAAMG,YAAY,GAAG,IAAAC,8BAAA,EAAsBJ,IAAtB,CAArB;;IAEA,IAAIG,YAAY,CAACE,OAAjB,EAA0B;MACxB,OAAO,KAAP;IACD;;IAEDN,YAAY,CAACC,IAAb,GAAoB,EAAE,GAAGA;IAAL,CAApB,CAfmB,CAiBnB;;IACAV,cAAA,CAAMgB,QAAN,CAAed,YAAf,CAA4Be,cAA5B,CAA2CP,IAA3C;;IAEA,MAAMQ,aAAa,GAAGhC,eAAe,CAACiC,SAAhB,CAA0BC,QAA1B,CACpBX,YAAY,CAACG,IADO,CAAtB;;IAIA,IAAIM,aAAa,IAAI,CAACxB,qBAAtB,EAA6C;MAC3C;MACAe,YAAY,CAACY,MAAb,GAAsB,CAAE,IAAF,CAAtB;MACA,OAAOZ,YAAP;IACD;;IAED,MAAMa,QAAQ,GAAGnC,OAAO,CAACwB,GAAR,CAAYF,YAAY,CAACG,IAAzB,CAAjB;IAEA,IAAIW,cAAc,GAAG,CAAC,GAAGD,QAAQ,CAACD,MAAb,CAArB;;IAEA,IAAI,CAAAhC,UAAU,SAAV,IAAAA,UAAU,WAAV,YAAAA,UAAU,CAAEmC,IAAZ,MAAsB,WAA1B,EAAsC;MACpC;MACAD,cAAc,GAAGA,cAAc,CAACE,MAAf,CACfC,aAAa,IACX,CAACrC,UAAU,CAACgC,MAAX,CAAkBM,IAAlB,CACCpC,WAAW,IAAIA,WAAW,CAACqB,IAAZ,KAAqBc,aAAa,CAACd,IADnD,CAFY,CAAjB;IAMD;;IAED,IAAIU,QAAJ,EAAc;MACZ,MAAMD,MAAM,GAAGO,0BAA0B,CAAC;QACxCP,MAAM,EAAEE,cADgC;QAExClC,UAAU,EAAEqB,IAF4B;QAGxCf,KAHwC;QAIxCE,iBAJwC;QAKxCL,SALwC;QAMxCI,gBANwC;QAOxCH,kBAPwC;QAQxCH,QARwC;QASxCC;MATwC,CAAD,CAAzC;;MAYA,IAAI,CAAC8B,MAAD,IAAW,CAACA,MAAM,CAACQ,MAAvB,EAA+B;QAC7B,OAAO,KAAP;MACD;;MAEDpB,YAAY,CAACY,MAAb,GAAsB,CAAC,GAAGA,MAAJ,CAAtB;MACA,OAAOZ,YAAP;IACD;;IAED,OAAO,KAAP;EACD,CAnEgC,EAoEhCgB,MApEgC,CAoEzBK,OApEyB,CAAnC;EAsEA,OAAO7C,aAAa,IAAIU,KAAK,IAAIP,QAA1B,GAAqCmB,0BAArC,GAAkE,IAAzE;AACD,CA5GM,C,CA8GP;;;;;AACA,MAAMwB,iBAAiB,GAAG,CAAC;EAAEC,QAAF;EAAYnC;AAAZ,CAAD;EAAA;;EAAA,OACxBA,iBAAiB,CAACgC,MAAlB,4BACIhC,iBAAiB,CAAC4B,MAAlB,CACEQ,gBAAgB,IAAIA,gBAAgB,KAAKD,QAD3C,CADJ,0DACI,sBAEGH,MAHP,GAII,CALoB;AAAA,CAA1B;;AAOO,SAASK,cAAT,CAAwB;EAC7BC,KAD6B;EAE7BjD,eAF6B;EAG7BC,OAH6B;EAI7BC,QAJ6B;EAK7BO,KAL6B;EAM7ByC,cAN6B;EAO7BC,YAP6B;EAQ7BxC,iBAAiB,EAAEC,uBARU;EAS7BL,kBAT6B;EAU7BD,SAV6B;EAW7BI,gBAX6B;EAY7BN;AAZ6B,IAa3B,EAbG,EAaC;EAAA;;EACN,MAAMO,iBAAiB,GAAG,CAAC,GAAGC,uBAAJ,CAA1B,CADM,CAGN;EACA;;EACA,IAAIH,KAAK,GAAGP,QAAZ,EAAsB;IACpB,OAAO,KAAP;EACD;;EAEDO,KAAK,GATC,CAWN;;EACA,IAAI,CAACwC,KAAD,IAAU,CAACA,KAAK,CAACzB,IAArB,EAA2B;IACzB,OAAO,KAAP;EACD;;EAED,MAAMG,YAAY,GAAG,IAAAC,8BAAA,EAAsBqB,KAAK,CAACzB,IAA5B,CAArB;;EAEA,IAAIG,YAAY,CAACE,OAAjB,EAA0B;IACxB,OAAO,KAAP;EACD,CApBK,CAsBN;EACA;;;EACA,MAAMiB,QAAQ,GAAG,IAAAM,0BAAA,EAAkBH,KAAK,CAACzB,IAAxB,CAAjB;EACA,MAAM6B,QAAQ,GAAG,IAAAC,qBAAA,EAAaL,KAAK,CAACzB,IAAnB,CAAjB;EAEA,MAAM+B,oBAAoB,GAAGV,iBAAiB,CAAC;IAC7CC,QAD6C;IAE7CnC;EAF6C,CAAD,CAA9C;;EAKA,IAAI4C,oBAAoB,GAAG,CAA3B,EAA8B;IAC5B;IACA;IACAC,cAAc,CAAC;MACbrB,MAAM,EAAElC,OAAO,CAACwB,GAAR,CAAYqB,QAAZ,EAAsBX,MADjB;MAEbX,IAAI,EAAEyB,KAAK,CAACzB,IAFC;MAGblB,SAHa;MAIb2C,KAJa;MAKbtC,iBAAiB,EAAEC,uBALN;MAMbH,KANa;MAObyC,cAPa;MAQbC,YARa;MASblD,OATa;MAUbD,eAVa;MAWbO,kBAXa;MAYba,UAAU,EAAElB,QAZC;MAabQ,gBAba;MAcbN;IAda,CAAD,CAAd;EAgBD;;EAED,IAAImD,oBAAoB,IAAIhD,kBAA5B,EAAgD;IAC9C,OAAO,KAAP;EACD,CAvDK,CAyDN;EACA;;;EACA,MAAMkD,SAAS,GAAG,IAAAC,uCAAA,EAAuB;IAAEP,YAAF;IAAgBF;EAAhB,CAAvB,CAAlB;;EAEA,IACEC,cAAc,CAAChB,QAAf,CAAwBe,KAAK,CAACvB,IAA9B,KACAwB,cAAc,CAAChB,QAAf,CAAwBuB,SAAxB,CAFF,EAGE;IACA,OAAO,KAAP;EACD,CAlEK,CAoEN;EACA;;;EACA,IACER,KAAK,CAACU,IAAN,IACAV,KAAK,CAACU,IAAN,CAAWhB,MADX,IAEAM,KAAK,CAACU,IAAN,CAAWlB,IAAX,CAAgBmB,GAAG;IAAA;;IAAA,OAAI,CAAAA,GAAG,SAAH,IAAAA,GAAG,WAAH,yBAAAA,GAAG,CAAEpC,IAAL,wDAAWc,IAAX,MAAqB,UAAzB;EAAA,CAAnB,CAHF,EAIE;IACA,OAAO,KAAP;EACD;;EAED,MAAMuB,SAAS,GAAG5D,OAAO,CAACwB,GAAR,CAAY,IAAA2B,0BAAA,EAAkBH,KAAK,CAACzB,IAAxB,CAAZ,KAA8C,EAAhE;EACA,MAAMsC,MAAM,GAAG7D,OAAO,CAACwB,GAAR,CAAY,IAAA2B,0BAAA,EAAkBS,SAAS,CAACC,MAA5B,CAAZ,KAAoD,EAAnE;;EAEA,IACED,SAAS,CAACvB,IAAV,KAAoB,QAApB,IACAuB,SAAS,CAACvB,IAAV,KAAoB,MADpB,IAECuB,SAAS,CAACvB,IAAV,KAAoB,UAApB,IAAiCwB,MAAM,CAACxB,IAAP,KAAiB,QAFnD,IAGCuB,SAAS,CAACvB,IAAV,KAAoB,MAApB,IAA6BuB,SAAS,CAACC,MAAV,CAAiBxB,IAAjB,KAA2B,QAHzD,IAIA;EACA;EACA;EACCW,KAAK,CAACzB,IAAN,CAAWc,IAAX,KAAqB,MAArB,IAA8B,gBAAAW,KAAK,CAACzB,IAAN,kFAAYsC,MAAZ,0EAAoBxB,IAApB,MAA8B,MAR/D,EASE;IACA,OAAO;MACLmB,SADK;MAELI;IAFK,CAAP;EAID;;EAED,MAAME,mBAAmB,GACvBD,MAAM,IAAI9D,eAAe,CAACiC,SAAhB,CAA0BC,QAA1B,CAAmCY,QAAnC,CADZ;EAGA,MAAMkB,kBAAkB,GAAGF,MAAM,IAAIhB,QAAQ,KAAM,WAAnD;EAEA,MAAMmB,UAAU,GAAGJ,SAAH,aAAGA,SAAH,4CAAGA,SAAS,CAAE1B,MAAd,sDAAG,kBAAmBM,IAAnB,CAAwB,CAAC;IAAEf;EAAF,CAAD,KAAcA,IAAI,KAAM,IAAhD,CAAnB;;EACA,IACEmC,SAAS,CAACvB,IAAV,KAAoB,MAApB,IACAyB,mBADA,IAEA,CAACC,kBAFD,IAGAC,UAJF,EAKE;IACA,OAAO;MACLR,SAAS,EAAEA,SADN;MAELtB,MAAM,EAAE,CAAE,YAAF,EAAgB,IAAhB,CAFH;MAGL0B;IAHK,CAAP;EAKD,CAXD,MAWO,IAAIA,SAAS,CAACvB,IAAV,KAAoB,MAApB,IAA6B0B,kBAA7B,IAAmDC,UAAvD,EAAmE;IACxE,OAAO;MACLR,SAAS,EAAEA,SADN;MAELtB,MAAM,EAAE,CAAE,YAAF,EAAgB,IAAhB,CAFH;MAGL0B;IAHK,CAAP;EAKD,CANM,MAMA,IAAIA,SAAS,CAACvB,IAAV,KAAoB,MAAxB,EAA+B;IACpC,MAAM4B,UAAU,GAAGjE,OAAO,CAACwB,GAAR,CAAY,IAAA2B,0BAAA,EAAkBS,SAAlB,CAAZ,CAAnB;IAEA,MAAMM,iBAAiB,GAAGzB,0BAA0B,CAAC;MACnDP,MAAM,EAAE+B,UAAU,CAAC/B,MADgC;MAEnDhC,UAAU,EAAE+D,UAAU,IAAIL,SAFyB;MAGnDpD,KAHmD;MAInDE,iBAJmD;MAKnDL,SALmD;MAMnDC,kBANmD;MAOnDG,gBAPmD;MAQnDN;IARmD,CAAD,CAApD;IAWA,MAAMiB,0BAA0B,GAAGvB,wBAAwB,CAAC;MAC1DC,aAAa,EAAEmE,UAAU,CAACnE,aADgC;MAE1DI,UAAU,EAAE+D,UAAU,IAAIL,SAFgC;MAG1DxD,WAAW,EAAE4C,KAH6C;MAI1D7C,QAJ0D;MAK1DJ,eAL0D;MAM1DC,OAN0D;MAO1DQ,KAP0D;MAQ1DP,QAR0D;MAS1DS,iBAT0D;MAU1DL,SAV0D;MAW1DC,kBAX0D;MAY1DG;IAZ0D,CAAD,CAA3D;;IAeA,IAAI,EAACyD,iBAAD,aAACA,iBAAD,eAACA,iBAAiB,CAAExB,MAApB,KAA8B,EAACtB,0BAAD,aAACA,0BAAD,eAACA,0BAA0B,CAAEsB,MAA7B,CAAlC,EAAuE;MACrE,OAAO,KAAP;IACD,CA/BmC,CAiCpC;;;IACA,OAAO;MACLc,SAAS,EAAEA,SADN;MAELtB,MAAM,EAAEgC,iBAFH;MAGLC,eAAe,EAAE/C,0BAHZ;MAILwC;IAJK,CAAP;EAMD;;EAED,MAAM7B,aAAa,GACjB;EACAhC,eAAe,CAACiC,SAAhB,CAA0BC,QAA1B,CAAmCY,QAAnC,OACA;EADA,gBAEA7C,OAAO,CACJwB,GADH,CACOqB,QADP,CAFA,0EAEA,aAEI/C,aAJJ,0DAEA,sBAEmBsE,KAFnB,CAEyB9C,YAAY,IACjCvB,eAAe,CAACiC,SAAhB,CAA0BC,QAA1B,CAAmCX,YAAY,CAACG,IAAhD,CAHJ,CAFA,CAFF;;EAUA,IAAIM,aAAa,IAAIiC,UAArB,EAAiC;IAC/B,OAAO;MACLR,SAAS,EAAEA,SADN;MAELtB,MAAM,EAAE,CAAE,YAAF,EAAgB,IAAhB,CAFH;MAGL0B;IAHK,CAAP;EAKD;;EAED,MAAMzB,QAAQ,GAAGnC,OAAO,CAACwB,GAAR,CAAY,IAAA2B,0BAAA,EAAkBS,SAAlB,CAAZ,CAAjB;EAEA,MAAM;IAAE1B;EAAF,IAAaC,QAAQ,IAAI,EAA/B;EAEA,IAAIf,0BAAJ;;EAEA,IAAIe,QAAQ,CAACrC,aAAb,EAA4B;IAC1BsB,0BAA0B,GAAGvB,wBAAwB,CAAC;MACpDC,aAAa,EAAEqC,QAAQ,CAACrC,aAD4B;MAEpDI,UAAU,EAAEiC,QAFwC;MAGpD/B,WAAW,EAAE4C,KAHuC;MAIpD7C,QAJoD;MAKpDJ,eALoD;MAMpDC,OANoD;MAOpDQ,KAPoD;MAQpDP,QARoD;MASpDS,iBAToD;MAUpDL,SAVoD;MAWpDC,kBAXoD;MAYpDG;IAZoD,CAAD,CAArD;EAcD;;EAED,IAAIyB,MAAM,IAAId,0BAAd,EAA0C;IAAA;;IACxC,MAAM8C,iBAAiB,GAAGzB,0BAA0B,CAAC;MACnDvC,UAAU,EAAEiC,QADuC;MAEnDkC,eAAe,EAAErB,KAAK,CAACvB,IAF4B;MAGnDtB,QAHmD;MAInD+B,MAJmD;MAKnD1B,KALmD;MAMnDE,iBANmD;MAOnDN,WAAW,EAAE4C,KAPsC;MAQnD3C,SARmD;MASnDC,kBATmD;MAUnDG;IAVmD,CAAD,CAApD;;IAaA,IAAI,EAACyD,iBAAD,aAACA,iBAAD,eAACA,iBAAiB,CAAExB,MAApB,KAA8B,2BAACtB,0BAAD,kDAAC,sBAA4BsB,MAA7B,CAAlC,EAAuE;MACrE,OAAO,KAAP;IACD;;IAED,OAAO;MACLc,SAAS,EAAEA,SADN;MAELtB,MAAM,EAAEgC,iBAFH;MAGLC,eAAe,EAAE/C,0BAHZ;MAILwC;IAJK,CAAP;EAMD;;EAED,IAAIA,SAAS,CAACvB,IAAV,KAAoB,OAAxB,EAAgC;IAC9B,MAAMF,QAAQ,GAAGnC,OAAO,CAACwB,GAAR,CAAYoC,SAAS,CAACnC,IAAtB,CAAjB;IAEA,MAAMyC,iBAAiB,GAAGzB,0BAA0B,CAAC;MACnDP,MAAM,EAAEC,QAAQ,CAACD,MADkC;MAEnDhC,UAAU,EAAE0D,SAFuC;MAGnDzD,QAHmD;MAInDK,KAJmD;MAKnDE,iBALmD;MAMnDL,SANmD;MAOnDC,kBAPmD;MAQnDG;IARmD,CAAD,CAApD;IAWA,MAAM0D,eAAe,GAAGtE,wBAAwB,CAAC;MAC/CC,aAAa,EAAEqC,QAAQ,CAACrC,aADuB;MAE/CC,eAF+C;MAG/CC,OAH+C;MAI/CG,QAJ+C;MAK/CK,KAL+C;MAM/CP,QAN+C;MAO/CS,iBAP+C;MAQ/CN,WAAW,EAAE4C,KARkC;MAS/C3C,SAT+C;MAU/CC,kBAV+C;MAW/CG;IAX+C,CAAD,CAAhD;IAcA,OAAO;MACL+C,SAAS,EAAEA,SADN;MAELtB,MAAM,EAAEgC,iBAFH;MAGLC,eAHK;MAILP;IAJK,CAAP;EAMD;;EAED,OAAO,KAAP;AACD;;AAED,MAAML,cAAc,GAAG,CAAC;EACtBrB,MADsB;EAEtBc,KAFsB;EAGtBzB,IAHsB;EAItBlB,SAJsB;EAKtB4C,cALsB;EAMtBC,YANsB;EAOtBlD,OAPsB;EAQtBD,eARsB;EAStBoB,UATsB;EAUtBT,iBAVsB;EAWtBP,QAXsB;EAYtBM,gBAAgB,GAAG;AAZG,CAAD,KAajB;EAAA;;EACJ,MAAMoC,QAAQ,GAAG,IAAAM,0BAAA,EAAkB5B,IAAlB,CAAjB;;EAEA,IAAId,gBAAJ,EAAsB;IACpB;IACA,OAAO,IAAP;EACD;;EAED,MAAM6D,yBAAyB,GAAGjE,SAAH,aAAGA,SAAH,uBAAGA,SAAS,CAAGwC,QAAH,CAA3C;;EAEA,IAAIyB,yBAAyB,IAAI7D,gBAAgB,KAAKoC,QAAtD,EAAgE;IAC9D,OAAOyB,yBAAP;EACD;;EAED,MAAMC,cAAc,GAAGrC,MAAM,CAACsC,MAAP,CAAc,CAACD,cAAD,EAAiBvB,KAAjB,KAA2B;IAAA;;IAC9D,MAAMyB,aAAa,GAAG,IAAAtB,0BAAA,EAAkBH,KAAK,CAACzB,IAAxB,CAAtB;IACA,MAAMqC,SAAS,GAAG5D,OAAO,CAACwB,GAAR,CAAYiD,aAAZ,CAAlB;;IAEA,KACE;IACA;IACAb,SAAS,CAACnC,IAAV,KAAmBoB,QAAnB,IACAe,SADA,aACAA,SADA,qCACAA,SAAS,CAAE1B,MADX,+CACA,mBAAmBM,IAAnB,CACEkC,eAAe,IAAI,IAAAvB,0BAAA,EAAkBuB,eAAe,CAACnD,IAAlC,MAA4CsB,QADjE,CAJF,EAOE;MACA,OAAO0B,cAAP;IACD;;IAED,MAAMI,gBAAgB,GAAG5B,cAAc,CAAC;MACtCC,KADsC;MAEtCjD,eAFsC;MAGtCC,OAHsC;MAItCC,QAAQ,EAAEkB,UAJ4B;MAKtCX,KAAK,EAAE,CAL+B;MAMtCyC,cANsC;MAOtCC,YAPsC;MAQtCxC,iBARsC;MAStCP,QATsC;MAUtCG,kBAAkB,EAAE,CAVkB;MAWtCD,SAXsC;MAYtCI,gBAAgB,EAAEoC;IAZoB,CAAD,CAAvC;;IAeA,IAAI,IAAAM,0BAAA,EAAkBH,KAAK,CAACzB,IAAxB,MAAkCsB,QAAlC,IAA8C,CAAC,CAAC8B,gBAApD,EAAsE;MACpEJ,cAAc,CAACK,IAAf,CAAoBD,gBAApB;IACD;;IAED,OAAOJ,cAAP;EACD,CAnCsB,EAmCpB,EAnCoB,CAAvB;EAqCA,MAAMM,SAAS,GAAG7E,OAAO,CAACwB,GAAR,CAAYqB,QAAZ,CAAlB;EAEA,MAAMzB,0BAA0B,GAAGyD,SAAS,SAAT,IAAAA,SAAS,WAAT,6BAAAA,SAAS,CAAE/E,aAAX,wEAA0B4C,MAA1B,GAC/B7C,wBAAwB,CAAC;IACvBC,aAAa,EAAE+E,SAAS,CAAC/E,aADF;IAEvBI,UAAU,EAAE2E,SAFW;IAGvBzE,WAAW,EAAE4C,KAHU;IAIvB7C,QAJuB;IAKvBJ,eALuB;IAMvBC,OANuB;IAOvBQ,KAAK,EAAE,CAPgB;IAQvBP,QAAQ,EAAEkB,UARa;IASvBb,kBAAkB,EAAE,CATG;IAUvBI,iBAVuB;IAWvBL,SAXuB;IAYvBI,gBAAgB,EAAEoC;EAZK,CAAD,CADO,GAe/B,IAfJ;;EAiBA,IAAIxC,SAAJ,EAAe;IACbA,SAAS,CAACwC,QAAD,CAAT,GAAsB;MACpBpB,IAAI,EAAG,GAAEoB,QAAS,UADE;MAEpBtB,IAAI,EAAEsB,QAFc;MAGpBX,MAAM,EAAEqC,cAHY;MAIpBJ,eAAe,EAAE/C;IAJG,CAAtB;EAMD;;EAED,OAAOmD,cAAP;AACD,CA7FD;;AA+FA,MAAMO,eAAe,GAAG,CAAC;EACvB5C,MADuB;EAEvBhC,UAFuB;EAGvBC,QAHuB;EAIvBE,SAJuB;EAKvBD,WALuB;EAMvBM,iBANuB;EAOvBF,KAPuB;EAQvByC,cARuB;EASvBC,YATuB;EAUvBlD,OAVuB;EAWvBD,eAXuB;EAYvBoB,UAZuB;EAavBb,kBAbuB;EAcvBU,aAduB;EAevBP;AAfuB,CAAD,KAiBtByB,MAjBsB,aAiBtBA,MAjBsB,uBAiBtBA,MAAM,CACFI,MADJ,CAEIU,KAAK,IACH,CAAC,IAAA+B,uCAAA,EAA4B;EAC3B/B,KAD2B;EAE3B9C;AAF2B,CAA5B,CAAD,IAIA,CAAC,IAAA8E,gCAAA,EAAqB;EACpBhE,aADoB;EAEpBgC;AAFoB,CAArB,CAPP,EAYG3B,GAZH,CAYO2B,KAAK,IAAI;EACZ,MAAM2B,gBAAgB,GAAG5B,cAAc,CAAC;IACtC9C,QAAQ,EAAEkB,UAD4B;IAEtCpB,eAFsC;IAGtCkD,cAHsC;IAItCC,YAJsC;IAKtClD,OALsC;IAMtCgD,KANsC;IAOtCxC,KAPsC;IAQtCE,iBARsC;IAStCJ,kBATsC;IAUtCD,SAVsC;IAWtCI,gBAXsC;IAYtCN,QAZsC;IAatCC;EAbsC,CAAD,CAAvC;;EAgBA,IAAIuE,gBAAJ,EAAsB;IACpB;IACA9D,cAAA,CAAMgB,QAAN,CAAed,YAAf,CAA4Be,cAA5B,CAA2CkB,KAAK,CAACzB,IAAjD;EACD;;EAED,MAAMsB,QAAQ,GAAG,IAAAM,0BAAA,EAAkBH,KAAK,CAACzB,IAAxB,CAAjB;EACA,MAAM0D,QAAQ,GAAG5E,SAAH,aAAGA,SAAH,uBAAGA,SAAS,CAAGwC,QAAH,CAA1B,CAvBY,CAyBZ;EACA;EACA;;EACA,IAAIoC,QAAQ,IAAIN,gBAAZ,IAAgClE,gBAAgB,KAAKoC,QAAzD,EAAmE;IAAA;;IACjE;IACA;IACA,IAAI8B,gBAAJ,aAAIA,gBAAJ,wCAAIA,gBAAgB,CAAEzC,MAAtB,kDAAI,sBAA0BQ,MAA9B,EAAsC;MACpCiC,gBAAgB,CAACzC,MAAjB,GAA0ByC,gBAAgB,CAACzC,MAAjB,CAAwBI,MAAxB,CACxBU,KAAK,IACH,CAACiC,QAAQ,CAAC/C,MAAT,CAAgBM,IAAhB,CACC0C,aAAa,IAAIA,aAAa,CAAC1B,SAAd,KAA4BR,KAAK,CAACQ,SADpD,CAFqB,CAA1B;IAMD,CAVgE,CAYjE;IACA;IACA;;;IACA,IAAI,CAACmB,gBAAgB,CAACzC,MAAtB,EAA8B;MAC5ByC,gBAAgB,CAACzC,MAAjB,GAA0B,EAA1B;IACD;;IAEDyC,gBAAgB,CAACzC,MAAjB,CAAwB0C,IAAxB,CAA6B;MAC3BO,YAAY,EAAG,UADY;MAE3BF;IAF2B,CAA7B;;IAKA,IAAIN,gBAAJ,aAAIA,gBAAJ,wCAAIA,gBAAgB,CAAER,eAAtB,kDAAI,sBAAmCzB,MAAvC,EAA+C;MAC7CiC,gBAAgB,CAACR,eAAjB,GACEQ,gBAAgB,CAACR,eAAjB,CAAiC7B,MAAjC,CACE8C,mBAAmB,IACjB;MACA,CAACH,QAAQ,CAACd,eAAT,CAAyB3B,IAAzB,CACC6C,sBAAsB,IACpBA,sBAAsB,CAAC5D,IAAvB,KAAgC2D,mBAAmB,CAAC3D,IAFvD,CAHL,CADF;IASD;EACF;;EAED,IAAIuB,KAAK,CAACd,MAAN,IAAgB,CAACyC,gBAArB,EAAuC;IACrC,OAAO,IAAP;EACD;;EAED,MAAMW,aAAa,GAAG,IAAAjC,qBAAA,EAAaL,KAAK,CAACzB,IAAnB,CAAtB;EACA,MAAMgE,eAAe,GAAG,IAAAlC,qBAAA,EAAaL,KAAK,CAACzB,IAAN,CAAWsC,MAAxB,CAAxB;EACA,MAAM2B,+BAA+B,GAAG,CAAE,QAAF,EAAY,OAAZ,EAAqB,WAArB,CAAxC;EACA,MAAMC,sBAAsB,GAC1BD,+BAA+B,CAACvD,QAAhC,CAAyCqD,aAAzC,KACAE,+BAA+B,CAACvD,QAAhC,CAAyCsD,eAAzC,CAFF;;EAIA,KACE;EACAE,sBAAsB,IACtB;EACA,CAACd,gBAAgB,CAACzC,MAFlB,IAGA;EACA,CAACyC,gBAAgB,CAACR,eANpB,EAOE;IACA;IACA;IACA;IACA,OAAO,IAAP;EACD;;EAED,OAAOQ,gBAAP;AACD,CAvGH,EAwGGrC,MAxGH,CAwGUK,OAxGV,CAjBF;;AA2HA,MAAMF,0BAA0B,GAAG,CAAC;EAClCP,MADkC;EAElChC,UAFkC;EAGlCC,QAHkC;EAIlCE,SAJkC;EAKlCD,WALkC;EAMlCM,iBAAiB,EAAEC,uBANe;EAOlCH,KAAK,GAAG,CAP0B;EAQlCC,gBAAgB,GAAG;AARe,CAAD,KAS7B;EACJ,IAAI,CAACyB,MAAD,IAAW,CAACA,MAAM,CAACQ,MAAvB,EAA+B;IAC7B,OAAO,IAAP;EACD;;EAED,IAAI,CAAC/B,uBAAL,EAA8B;IAC5BA,uBAAuB,GAAG,EAA1B;EACD;;EAED,MAAMD,iBAAiB,GAAG,CAAC,GAAGC,uBAAJ,CAA1B;;EAEA,MAAM;IACJM,SAAS,EAAE;MAAED;IAAF,CADP;IAEJD,YAAY,EAAE;MAAEkC,cAAF;MAAkBC,YAAlB;MAAgClD,OAAhC;MAAyCD;IAAzC;EAFV,IAGFc,cAAA,CAAMC,QAAN,EAHJ;;EAKA,MAAM;IACJI,MAAM,EAAE;MAAEC,UAAF;MAAcb;IAAd;EADJ,IAEFU,aAFJ;;EAIA,IAAIR,KAAK,GAAGW,UAAR,IAAsBT,iBAAiB,CAACgC,MAA5C,EAAoD;IAClD,OAAO,IAAP;EACD;;EAED,MAAMG,QAAQ,GAAG,IAAAM,0BAAA,EAAkBjD,UAAlB,CAAjB;EAEA,MAAMwF,mBAAmB,GAAGhF,iBAAiB,CAACgC,MAAlB,GACxBhC,iBAAiB,CAACA,iBAAiB,CAACgC,MAAlB,GAA2B,CAA5B,CADO,GAExB,IAFJ;;EAIA,IAAIgD,mBAAmB,IAAI7C,QAAQ,KAAK6C,mBAAxC,EAA6D;IAC3D;IACA;IACA;IACA;IACA;IACA;IACAxD,MAAM,GAAGA,MAAM,CAACI,MAAP,CAAcU,KAAK,IAAI;MAC9B,MAAMyB,aAAa,GAAG,IAAAtB,0BAAA,EAAkBH,KAAK,CAACzB,IAAxB,CAAtB;MACA,OAAOkD,aAAa,KAAKiB,mBAAzB;IACD,CAHQ,CAAT;EAID;;EAED,MAAMpC,oBAAoB,GAAGV,iBAAiB,CAAC;IAC7CC,QAD6C;IAE7CnC;EAF6C,CAAD,CAA9C;;EAKA,IAAI4C,oBAAoB,IAAIhD,kBAA5B,EAAgD;IAC9C,OAAO,IAAP;EACD;;EAEDK,uBAAuB,CAACiE,IAAxB,CAA6B/B,QAA7B;EAEA,MAAM8C,4BAA4B,GAAGb,eAAe,CAAC;IACnD5C,MADmD;IAEnDhC,UAFmD;IAGnDC,QAHmD;IAInDE,SAJmD;IAKnDD,WALmD;IAMnDM,iBAAiB,EAAEC,uBANgC;IAOnDH,KAPmD;IAQnDyC,cARmD;IASnDC,YATmD;IAUnDlD,OAVmD;IAWnDD,eAXmD;IAYnDoB,UAZmD;IAanDb,kBAbmD;IAcnDU,aAdmD;IAenDP;EAfmD,CAAD,CAApD;;EAkBA,IAAI,CAACkF,4BAA4B,CAACjD,MAAlC,EAA0C;IACxC,OAAO,IAAP;EACD;;EAED,OAAOiD,4BAAP;AACD,CAtFD;;eAwFelD,0B"}