{"version":3,"file":"index.js","names":["handleCustomScalars","field","fieldTypeIsACustomScalar","type","kind","typeIsASupportedScalar","name","fieldTypeOfTypeIsACustomScalar","ofType","getAliasedFieldName","fieldAliases","returnAliasedFieldName","fieldIsExcluded","fieldName","thisTypeSettings","fieldBlacklist","parentTypeSettings","parentInterfacesImplementingTypeSettings","fieldOfTypeWasFetched","excludeFieldNames","includes","find","typeSetting","excludedFieldName","exclude","args","arg","findNamedTypeName","transformFields","fields","parentType","parentInterfacesImplementingTypes","peek","length","gatsbyNodeTypes","getGatsbyNodeTypeNames","store","getState","remoteSchema","getTypeSettingsByType","map","transformedFields","reduce","fieldsObject","typeMap","get","includedChildFields","filter","childFieldTypeSettings","Array","isArray","transform","description","fieldTransformers","test","transformerApi","transformedField","resolve","buildDefaultResolver","Object","keys"],"sources":["../../../../src/steps/create-schema-customization/transform-fields/index.js"],"sourcesContent":["import { fieldTransformers } from \"./field-transformers\"\nimport { getGatsbyNodeTypeNames } from \"../../source-nodes/fetch-nodes/fetch-nodes\"\nimport store from \"~/store\"\n\nimport {\n  fieldOfTypeWasFetched,\n  typeIsASupportedScalar,\n  getTypeSettingsByType,\n  findNamedTypeName,\n} from \"../helpers\"\n\nimport { buildDefaultResolver } from \"./default-resolver\"\n\nconst handleCustomScalars = field => {\n  const fieldTypeIsACustomScalar =\n    field.type.kind === `SCALAR` && !typeIsASupportedScalar(field.type)\n\n  if (fieldTypeIsACustomScalar) {\n    // if this field is an unsupported custom scalar,\n    // type it as JSON\n    field.type.name = `JSON`\n  }\n\n  const fieldTypeOfTypeIsACustomScalar =\n    field.type.ofType &&\n    field.type.ofType.kind === `SCALAR` &&\n    !typeIsASupportedScalar(field.type)\n\n  if (fieldTypeOfTypeIsACustomScalar) {\n    // if this field is an unsupported custom scalar,\n    // type it as JSON\n    field.type.ofType.name = `JSON`\n  }\n\n  return field\n}\n\n// this is used to alias fields that conflict with Gatsby node fields\n// for ex Gatsby and WPGQL both have a `parent` field\nexport const getAliasedFieldName = ({ fieldAliases, field }) =>\n  fieldAliases && fieldAliases[field.name]\n    ? fieldAliases[field.name]\n    : field.name\n\nexport const returnAliasedFieldName = ({ fieldAliases, field }) =>\n  fieldAliases && fieldAliases[field.name]\n    ? `${fieldAliases[field.name]}: ${field.name}`\n    : field.name\n\nconst fieldIsExcluded = ({\n  field,\n  fieldName,\n  thisTypeSettings,\n  fieldBlacklist,\n  parentTypeSettings,\n  parentInterfacesImplementingTypeSettings,\n}) =>\n  // this field wasn't previously fetched, so we shouldn't\n  // add it to our schema\n  (!fieldOfTypeWasFetched(field.type) && fieldName !== `id`) ||\n  // this field was excluded on its parent fields Type\n  (parentTypeSettings.excludeFieldNames &&\n    parentTypeSettings.excludeFieldNames.includes(fieldName)) ||\n  // this field is on an interface type and one of the implementing types has this field excluded on it.\n  (parentInterfacesImplementingTypeSettings &&\n    parentInterfacesImplementingTypeSettings.find(\n      typeSetting =>\n        typeSetting.excludeFieldNames &&\n        typeSetting.excludeFieldNames.find(\n          excludedFieldName => fieldName === excludedFieldName\n        )\n    )) ||\n  // the type of this field was excluded via plugin options\n  thisTypeSettings.exclude ||\n  // field is blacklisted\n  fieldBlacklist.includes(fieldName) ||\n  // this field has required input args\n  (field.args && field.args.find(arg => arg.type.kind === `NON_NULL`)) ||\n  // this field has no typeName\n  !findNamedTypeName(field.type)\n\n/**\n * Transforms fields from the WPGQL schema to work in the Gatsby schema\n * with proper node linking and type namespacing\n * also filters out unusable fields and types\n */\nexport const transformFields = ({\n  fields,\n  parentType,\n  parentInterfacesImplementingTypes,\n  peek = false,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  const gatsbyNodeTypes = getGatsbyNodeTypeNames()\n\n  const { fieldAliases, fieldBlacklist } = store.getState().remoteSchema\n\n  const parentTypeSettings = getTypeSettingsByType(parentType)\n\n  const parentInterfacesImplementingTypeSettings =\n    parentInterfacesImplementingTypes\n      ? parentInterfacesImplementingTypes.map(type =>\n          getTypeSettingsByType(type)\n        )\n      : null\n\n  const transformedFields = fields.reduce((fieldsObject, field) => {\n    // if there's no field name this field is unusable\n    if (field.name === ``) {\n      return fieldsObject\n    }\n\n    const thisTypeSettings = getTypeSettingsByType(field.type)\n\n    const fieldName = getAliasedFieldName({ fieldAliases, field })\n\n    if (\n      fieldIsExcluded({\n        field,\n        fieldName,\n        thisTypeSettings,\n        fieldBlacklist,\n        parentTypeSettings,\n        parentInterfacesImplementingTypeSettings,\n      })\n    ) {\n      return fieldsObject\n    }\n\n    const { typeMap } = store.getState().remoteSchema\n\n    const type = typeMap.get(findNamedTypeName(field.type))\n\n    const includedChildFields = type?.fields?.filter(field => {\n      const childFieldTypeSettings = getTypeSettingsByType(field.type)\n      const fieldName = getAliasedFieldName({ fieldAliases, field })\n      return !fieldIsExcluded({\n        field,\n        fieldName,\n        thisTypeSettings: childFieldTypeSettings,\n        fieldBlacklist,\n        parentTypeSettings: thisTypeSettings,\n        parentInterfacesImplementingTypeSettings,\n      })\n    })\n\n    // if the child fields of this field are all excluded,\n    // we shouldn't add this field\n    // @todo move this to a central location.\n    // if a type is missing all it's child fields due to exclusion\n    // it should be globally excluded automatically.\n    if (Array.isArray(includedChildFields) && !includedChildFields.length) {\n      return fieldsObject\n    }\n\n    field = handleCustomScalars(field)\n\n    const { transform, description } =\n      peek === false\n        ? fieldTransformers.find(({ test }) => test(field)) || {}\n        : {}\n\n    if (transform && typeof transform === `function` && peek === false) {\n      const transformerApi = {\n        field,\n        fieldsObject,\n        fieldName,\n        gatsbyNodeTypes,\n        description,\n      }\n\n      let transformedField = transform(transformerApi)\n\n      // add default resolver\n      if (typeof transformedField === `string`) {\n        // we need to add a custom resolver to override the default resolver\n        // and check for aliased fields\n        // fields are aliased automatically if they have conflicting types\n        // with other fields of the same name when placed in side-by-side\n        // inlineFragments on the same union or interface type.\n        transformedField = {\n          type: transformedField,\n          resolve: buildDefaultResolver(transformerApi),\n          description: field.description,\n        }\n      } else {\n        transformedField.description = field.description\n      }\n\n      fieldsObject[fieldName] = transformedField\n    } else if (peek) {\n      fieldsObject[fieldName] = true\n    }\n\n    return fieldsObject\n  }, {})\n\n  if (!Object.keys(transformedFields).length) {\n    return null\n  }\n\n  return transformedFields\n}\n"],"mappings":"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"}