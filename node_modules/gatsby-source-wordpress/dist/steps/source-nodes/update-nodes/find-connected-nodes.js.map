{"version":3,"file":"find-connected-nodes.js","names":["recursivelySearchForIds","key","value","Array","isArray","dump","map","innerValue","Object","values","entries","findConnectedNodeIds","node","childNodeIds","Set","flattenDeep","filter","id","length"],"sources":["../../../../src/steps/source-nodes/update-nodes/find-connected-nodes.js"],"sourcesContent":["import flattenDeep from \"lodash/flattenDeep\"\nimport { dump } from \"dumper.js\"\n\n// After all nodes are created while building the schema, store possible node type relationships. So for example when building the WpPost type, for every gatsby node discovered as a potential connected node type WpPost's fields, record that in redux as WpPost => [...ConnectedTypeNames].\n\n// when creating or updating a Page incrementally, we should find all connected node ids, check the types of each of those id's, if any connected id type has the current node type as a potential connected node type, AND this node is not a connected node of that node, we should refetch that node in case it's now a connected node.\n\n// So we create a new Page, we then check the connected node id's and determine that one of them is a User type. The User type has Page as a potential connected node. So we check if this node is a connected node of that node. If it's not we can't be sure that that User node isn't missing this node as a connected node. So we refetch the connected node of our Page which is a User. Do this for all connected nodes where we can't find a relationship back.\n\nconst recursivelySearchForIds = ([key, value]) => {\n  if (!key || !value) {\n    return null\n  }\n\n  if (key === `id`) {\n    return value\n  } else if (typeof value === `string` || typeof value === `number`) {\n    return null\n  }\n\n  if (Array.isArray(value)) {\n    dump(key)\n    // loop through each value of the array. If it's an object recurse on it's fields\n    // if it's anything else skip it.\n    value.map(innerValue => {\n      if (innerValue === null) {\n        return null\n      }\n\n      if (key === `id` && typeof innerValue === `string`) {\n        return innerValue\n      }\n\n      if (typeof innerValue === `object`) {\n        return Object.values(innerValue).map(recursivelySearchForIds)\n      }\n\n      return null\n    })\n  } else if (typeof value === `object`) {\n    dump(key)\n    return Object.entries(value).map(recursivelySearchForIds)\n  }\n\n  return null\n}\n\nexport const findConnectedNodeIds = node => {\n  const childNodeIds = [\n    ...new Set(\n      flattenDeep(Object.entries(node).map(recursivelySearchForIds)).filter(\n        id => id !== node.id && !!id\n      )\n    ),\n  ]\n\n  if (!childNodeIds.length) {\n    return null\n  }\n\n  return childNodeIds\n}\n"],"mappings":";;;;;;;AAAA;;AACA;;AAEA;AAEA;AAEA;AAEA,MAAMA,uBAAuB,GAAG,CAAC,CAACC,GAAD,EAAMC,KAAN,CAAD,KAAkB;EAChD,IAAI,CAACD,GAAD,IAAQ,CAACC,KAAb,EAAoB;IAClB,OAAO,IAAP;EACD;;EAED,IAAID,GAAG,KAAM,IAAb,EAAkB;IAChB,OAAOC,KAAP;EACD,CAFD,MAEO,IAAI,OAAOA,KAAP,KAAkB,QAAlB,IAA6B,OAAOA,KAAP,KAAkB,QAAnD,EAA4D;IACjE,OAAO,IAAP;EACD;;EAED,IAAIC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;IACxB,IAAAG,YAAA,EAAKJ,GAAL,EADwB,CAExB;IACA;;IACAC,KAAK,CAACI,GAAN,CAAUC,UAAU,IAAI;MACtB,IAAIA,UAAU,KAAK,IAAnB,EAAyB;QACvB,OAAO,IAAP;MACD;;MAED,IAAIN,GAAG,KAAM,IAAT,IAAgB,OAAOM,UAAP,KAAuB,QAA3C,EAAoD;QAClD,OAAOA,UAAP;MACD;;MAED,IAAI,OAAOA,UAAP,KAAuB,QAA3B,EAAoC;QAClC,OAAOC,MAAM,CAACC,MAAP,CAAcF,UAAd,EAA0BD,GAA1B,CAA8BN,uBAA9B,CAAP;MACD;;MAED,OAAO,IAAP;IACD,CAdD;EAeD,CAnBD,MAmBO,IAAI,OAAOE,KAAP,KAAkB,QAAtB,EAA+B;IACpC,IAAAG,YAAA,EAAKJ,GAAL;IACA,OAAOO,MAAM,CAACE,OAAP,CAAeR,KAAf,EAAsBI,GAAtB,CAA0BN,uBAA1B,CAAP;EACD;;EAED,OAAO,IAAP;AACD,CApCD;;AAsCO,MAAMW,oBAAoB,GAAGC,IAAI,IAAI;EAC1C,MAAMC,YAAY,GAAG,CACnB,GAAG,IAAIC,GAAJ,CACD,IAAAC,oBAAA,EAAYP,MAAM,CAACE,OAAP,CAAeE,IAAf,EAAqBN,GAArB,CAAyBN,uBAAzB,CAAZ,EAA+DgB,MAA/D,CACEC,EAAE,IAAIA,EAAE,KAAKL,IAAI,CAACK,EAAZ,IAAkB,CAAC,CAACA,EAD5B,CADC,CADgB,CAArB;;EAQA,IAAI,CAACJ,YAAY,CAACK,MAAlB,EAA0B;IACxB,OAAO,IAAP;EACD;;EAED,OAAOL,YAAP;AACD,CAdM"}